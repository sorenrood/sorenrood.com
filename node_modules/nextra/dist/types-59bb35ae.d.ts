import { NextConfig } from 'next';
import { Heading as Heading$1 } from 'mdast';
import { ProcessorOptions } from '@mdx-js/mdx';
import { Options } from 'rehype-pretty-code';
import { GrayMatterFile } from 'gray-matter';
import { Compiler } from 'webpack';
import { ReactNode, FC } from 'react';

declare const collectMdx: (filePath: string, route?: string) => Promise<MdxFile>;
declare function collectFiles(dir: string, locales?: string[], route?: string, fileMap?: FileMap): Promise<{
    items: PageMapItem[];
    fileMap: FileMap;
}>;
declare class PageMapCache {
    cache: {
        items: PageMapItem[];
        fileMap: FileMap;
    } | null;
    set(data: {
        items: PageMapItem[];
        fileMap: FileMap;
    }): void;
    clear(): void;
    get(): {
        items: PageMapItem[];
        fileMap: FileMap;
    } | null;
}
declare const pageMapCache: PageMapCache;
declare class NextraPlugin {
    private config;
    constructor(config: NextraConfig & {
        locales: string[];
    });
    apply(compiler: Compiler): void;
}

declare const MARKDOWN_EXTENSION_REGEX: RegExp;
declare const MARKDOWN_URL_EXTENSION_REGEX: RegExp;
declare const IS_PRODUCTION: boolean;
declare const LOCALE_REGEX: RegExp;
declare const DEFAULT_LOCALE = "en-US";
declare const DEFAULT_CONFIG: Omit<NextraConfig, 'theme'>;
declare const OFFICIAL_THEMES: string[];
declare const META_FILENAME = "_meta.json";
declare const DYNAMIC_META_FILENAME = "_meta.js";
declare const CWD: string;
declare const MARKDOWN_EXTENSIONS: readonly ["md", "mdx"];
declare const PUBLIC_DIR: string;
declare const EXTERNAL_URL_REGEX: RegExp;
declare const NEXTRA_INTERNAL: unique symbol;
declare const CODE_BLOCK_FILENAME_REGEX: RegExp;
declare const DEFAULT_LOCALES: string[];
declare const ERROR_ROUTES: Set<string>;

type MetaFilename = typeof META_FILENAME;
type MarkdownExtension = (typeof MARKDOWN_EXTENSIONS)[number];
interface LoaderOptions extends NextraConfig {
    isMetaImport?: boolean;
    isPageImport?: boolean;
    locales: string[];
    defaultLocale: string;
    pageMapCache: PageMapCache;
    newNextLinkBehavior?: boolean;
}
interface Folder<FileType = PageMapItem> {
    kind: 'Folder';
    name: string;
    route: string;
    children: FileType[];
}
type MetaJsonFile = {
    kind: 'Meta';
    locale?: string;
    data: {
        [fileName: string]: Meta;
    };
    __nextra_src?: string;
};
type DynamicFolder = {
    type: 'folder';
    items: DynamicMeta;
    title?: string;
};
type DynamicMetaItem = Meta | DynamicFolder;
type DynamicMeta = Record<string, DynamicMetaItem>;
type DynamicMetaJsonFile = {
    kind: 'Meta';
    locale?: string;
    data: DynamicMeta;
};
type FrontMatter = GrayMatterFile<string>['data'];
type Meta = string | Record<string, any>;
type MdxFile<FrontMatterType = FrontMatter> = {
    kind: 'MdxPage';
    name: string;
    route: string;
    locale?: string;
    frontMatter?: FrontMatterType;
};
type MetaJsonPath = `${string}/${MetaFilename}`;
type MdxPath = `${string}.${MarkdownExtension}`;
type FileMap = {
    [jsonPath: MetaJsonPath]: MetaJsonFile;
    [mdxPath: MdxPath]: MdxFile;
};
type PageMapItem = Folder | MdxFile | MetaJsonFile;
type Page = (MdxFile | Folder<Page>) & {
    meta?: Exclude<Meta, string>;
};
type Heading = Omit<Heading$1, 'type' | 'children' | 'position'> & {
    value: string;
    id: string;
};
type PageOpts<FrontMatterType = FrontMatter> = {
    filePath: string;
    route: string;
    frontMatter: FrontMatterType;
    pageMap: PageMapItem[];
    title: string;
    headings: Heading[];
    hasJsxInH1?: boolean;
    timestamp?: number;
    flexsearch?: Flexsearch;
    newNextLinkBehavior?: boolean;
    readingTime?: ReadingTime;
};
type ReadingTime = {
    text: string;
    minutes: number;
    time: number;
    words: number;
};
type Theme = string;
type Flexsearch = boolean | {
    /**
     * Whether to index code blocks
     * @default true
     */
    codeblocks: boolean;
    /**
     * A filter function to filter out files from indexing, and return the
     * index file key, or null to skip indexing.
     * A site can have multiple indexes, by default they're separated by
     * locales as multiple index files.
     */
    indexKey?: (filepath: string, route: string, locale?: string) => null | string;
};
type Transform = (result: string, options: {
    route: string;
}) => string | Promise<string>;
type NextraConfig = {
    theme: Theme;
    themeConfig?: string;
    defaultShowCopyCode?: boolean;
    flexsearch?: Flexsearch;
    staticImage?: boolean;
    readingTime?: boolean;
    latex?: boolean;
    codeHighlight?: boolean;
    /**
     * A function to modify the code of compiled MDX pages.
     * @experimental
     */
    transform?: Transform;
    /**
     * A function to modify the `pageOpts` prop passed to theme layouts.
     * @experimental
     */
    transformPageOpts?: (pageOpts: PageOpts) => PageOpts;
    mdxOptions?: Pick<ProcessorOptions, 'rehypePlugins' | 'remarkPlugins'> & {
        format?: 'detect' | 'mdx' | 'md';
        rehypePrettyCodeOptions?: Partial<Options>;
    };
};
type Nextra = (...args: [NextraConfig] | [theme: Theme, themeConfig: string]) => (nextConfig: NextConfig) => NextConfig;
declare const nextra: Nextra;

type ThemeConfig = any | null;
type NextraThemeLayoutProps = {
    pageOpts: PageOpts;
    pageProps: any;
    themeConfig: ThemeConfig;
    children: ReactNode;
};
type NextraInternalGlobal = typeof globalThis & {
    [NEXTRA_INTERNAL]: {
        pageMap: PageMapItem[];
        route: string;
        context: Record<string, {
            Content: FC;
            pageOpts: PageOpts;
            themeConfig: ThemeConfig;
        }>;
        refreshListeners: Record<string, (() => void)[]>;
        Layout: FC<any>;
        themeConfig?: ThemeConfig;
        flexsearch?: Flexsearch;
    };
};
type DynamicMetaDescriptor = {
    metaFilePath: string;
    metaObjectKeyPath: string;
    metaParentKeyPath: string;
};

export { DynamicMeta as A, FrontMatter as B, CWD as C, DynamicMetaDescriptor as D, EXTERNAL_URL_REGEX as E, Folder as F, MetaJsonPath as G, Heading as H, IS_PRODUCTION as I, MdxPath as J, NextraConfig as K, LoaderOptions as L, MdxFile as M, NextraPlugin as N, OFFICIAL_THEMES as O, Page as P, Nextra as Q, ReadingTime as R, NextraThemeLayoutProps as S, ThemeConfig as T, NextraInternalGlobal as U, PageMapItem as a, FileMap as b, DynamicMetaJsonFile as c, PageOpts as d, Meta as e, collectMdx as f, collectFiles as g, PageMapCache as h, MARKDOWN_EXTENSION_REGEX as i, MARKDOWN_URL_EXTENSION_REGEX as j, LOCALE_REGEX as k, DEFAULT_LOCALE as l, DEFAULT_CONFIG as m, META_FILENAME as n, DYNAMIC_META_FILENAME as o, pageMapCache as p, MARKDOWN_EXTENSIONS as q, PUBLIC_DIR as r, NEXTRA_INTERNAL as s, CODE_BLOCK_FILENAME_REGEX as t, DEFAULT_LOCALES as u, ERROR_ROUTES as v, nextra as w, MetaJsonFile as x, DynamicFolder as y, DynamicMetaItem as z };
